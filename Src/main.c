/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************куку
 */

#include "main.h"
#include "usart1.h"
#include "mavlink/mavlink.h"

void initGpio();
int ClockInit();



uint8_t str[] = "Received message with ID %d, sequence: %d from component %d of system %d\n";
uint8_t str_attitude[] = "Attitude{time_boot_ms: %d, roll: %d, pitch: %d}\n";
uint8_t str_heartbeat[] = "Heartbeat{custom_mode: %d, type: %d, autopilot: %d, base_mode: %d, system_status: %d, mavlink_version: %d }\n";
uint8_t attitudestr[] = "";
uint8_t printBuffer[100];


int main(void) {

	ClockInit();
	initGpio();
	USART_init();
	mavlink_status_t status;
	mavlink_message_t msg;
	int chan = 0;
	while (1) {
//		GPIOC->BSRR = 1<<13;
//		for (int var = 0; var < 7000000; ++var) {
//			__asm("nop");
//		}
//		GPIOC->BRR = 1<<13;
//		for (int var = 0; var < 7000000; ++var) {
//			__asm("nop");
//		}
//		while(USART_available()){
//			USART_WriteByte(USART_readByte());
//		}

		if (USART_available()) {
			uint8_t byte = USART_readByte();
			if (mavlink_frame_char(chan, byte, &msg, &status)!= MAVLINK_FRAMING_INCOMPLETE) {
				sprintf(printBuffer, str, msg.msgid, msg.seq, msg.compid, msg.sysid);
				USART_write(printBuffer, 100);
				switch (msg.msgid) {
					case 30:
					{
						mavlink_attitude_t attitude;
						mavlink_msg_attitude_decode(&msg, &attitude);
						sprintf(printBuffer, str_attitude, attitude.time_boot_ms, (int)attitude.roll, (int)attitude.pitch);
						USART_print(printBuffer);
					}
						break;
					case MAVLINK_MSG_ID_HEARTBEAT:
					{
						mavlink_heartbeat_t heartbeat;
						mavlink_msg_heartbeat_decode(&msg, &heartbeat);
						sprintf(printBuffer, str_heartbeat, heartbeat.custom_mode, heartbeat.type, heartbeat.base_mode, heartbeat.system_status, heartbeat.mavlink_version);
						USART_print(printBuffer);
					}
						break;
					default:
						break;
				}
			}
		}
	}
}



//Настраиваем тактирование системы от внешнего кварца
//через PLL на саксимально возможных частотах.
//Внешний кварц должен быть на 8МГц
//Возвращает:
//  0 - завершено успешно
//  1 - не запустился кварцевый генератор
//  2 - не запустился PLL
int ClockInit(void)
{
  __IO int StartUpCounter;

  ////////////////////////////////////////////////////////////
  //Запускаем кварцевый генератор
  ////////////////////////////////////////////////////////////

  RCC->CR |= (1<<RCC_CR_HSEON_Pos); //Запускаем генератор HSE

  //Ждем успешного запуска или окончания тайм-аута
  for(StartUpCounter=0; ; StartUpCounter++)
  {
    //Если успешно запустилось, то
    //выходим из цикла
    if(RCC->CR & (1<<RCC_CR_HSERDY_Pos))
      break;

    //Если не запустилось, то
    //отключаем все, что включили
    //и возвращаем ошибку
    if(StartUpCounter > 0x1000)
    {
      RCC->CR &= ~(1<<RCC_CR_HSEON_Pos); //Останавливаем HSE
      return 1;
    }
  }

  ////////////////////////////////////////////////////////////
  //Настраиваем и запускаем PLL
  ////////////////////////////////////////////////////////////

  //Настраиваем PLL
  RCC->CFGR |= (0x07<<RCC_CFGR_PLLMULL_Pos) //PLL множитель равен 9
            | (0x01<<RCC_CFGR_PLLSRC_Pos); //Тактирование PLL от HSE


  RCC->CR |= (1<<RCC_CR_PLLON_Pos); //Запускаем PLL

  //Ждем успешного запуска или окончания тайм-аута
  for(StartUpCounter=0; ; StartUpCounter++)
  {
    //Если успешно запустилось, то
    //выходим из цикла
    if(RCC->CR & (1<<RCC_CR_PLLRDY_Pos))
      break;

    //Если по каким-то причинам не запустился PLL, то
    //отключаем все, что включили
    //и возвращаем ошибку
    if(StartUpCounter > 0x1000)
    {
      RCC->CR &= ~(1<<RCC_CR_HSEON_Pos); //Останавливаем HSE
      RCC->CR &= ~(1<<RCC_CR_PLLON_Pos); //Останавливаем PLL
      return 2;
    }
  }

  ////////////////////////////////////////////////////////////
  //Настраиваем FLASH и делители
  ////////////////////////////////////////////////////////////

  //Устанавливаем 2 цикла ожидания для Flash
  //так как частота ядра у нас будет 48 MHz < SYSCLK <= 72 MHz
  FLASH->ACR |= (0x02<<FLASH_ACR_LATENCY_Pos);

  //Делители
  RCC->CFGR |= (0x00<<RCC_CFGR_PPRE2_Pos) //Делитель шины APB2 отключен
            | (0x04<<RCC_CFGR_PPRE1_Pos) //Делитель нишы APB1 равен 2
            | (0x00<<RCC_CFGR_HPRE_Pos); //Делитель AHB отключен


  RCC->CFGR |= (0x02<<RCC_CFGR_SW_Pos); //Переключаемся на работу от PLL

  //Ждем, пока переключимся
  while((RCC->CFGR & RCC_CFGR_SWS_Msk) != (0x02<<RCC_CFGR_SWS_Pos))
  {
  }

  //После того, как переключились на
  //внешний источник такирования
  //отключаем внутренний RC-генератор
  //для экономии энергии
  RCC->CR &= ~(1<<RCC_CR_HSION_Pos);

  //Настройка и переклбючение сисемы
  //на внешний кварцевый генератор
  //и PLL запершилось успехом.
  //Выходим
  return 0;
}

void initGpio() {
	RCC->APB2ENR |= RCC_APB2ENR_IOPCEN; //Включаем тактирование порта GPIOB
	GPIOC->CRH &= ~(GPIO_CRH_MODE13 | GPIO_CRH_CNF13); //для начала все сбрасываем в ноль
	GPIOC->CRH |= GPIO_CRH_MODE13_1; //выход с максимальной частотой 2 МГц
	GPIOC->CRH |= (0x02 << GPIO_CRH_MODE13_Pos) | (0x00 << GPIO_CRH_CNF13_Pos);
}
